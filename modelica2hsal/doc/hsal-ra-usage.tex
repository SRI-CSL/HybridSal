\documentclass{article}

\usepackage{amssymb}
\usepackage{url}
\newtheorem{definition}{Definition}

\begin{document}

\title{HybridSAL Relational Abstractor: User's Guide}
\author{Ashish Tiwari}

\maketitle

\section{Introduction}

HybridSal Relational Abstractor is a formal verification tool for
verifying safety properties of cyber-physical (hybrid dynamical) systems.
Here, we briefly describe one standard way of using the tool for 
performing verification.  This report does {\em{not}} describe the
technical approach, which can be found in other publications~\cite{ST11:CAV,hsalrelabs,ZST12:CAV}.
We focus on the inputs to the tool, how to run the tool, and the 
expected outputs of the tool here.

\section{Components of the Tool}

The HybridSal Relational Abstractor has three main components:
\begin{enumerate}
\item
 A {\tt{modelica2hsal}} translater (optional):
 This component converts an XML dump generated by OpenModelica into a HybridSal model.
\item
 A {\tt{hsal2hasal}} relational abstracter:
 This component takes as input a model (in HybridSal, such as the one generated by 
 {\tt{modelica2hsal}}) and creates an abstraction that is output in SAL syntax.
\item
 A {\tt{SAL model checker}} that performs verification on the abstract SAL model.
\end{enumerate}

These three components are run sequentially in that order. 
There are two possible outcomes of the verification effort:
either the property is proved, or a counter-example is found and reported
(by the last component, the SAL model checker, in the chain).

While it is not necessary to know about the existence of these three components,
it is useful to know about them for making best use of the HybridSal verification
technology.  In particular, for maximum benefit, the human user may need to 
``close-the-loop'' -- when verification fails and the user believes the property
should have been valid, the user needs to modify the model or the property by
analyzing the counter-example.

\section{Installing the Tool}

The {\tt{modelica2hsal}} translater and the {\tt{hsal2hasal}} relational abstracter
are available open-source and are essentially Python scripts that require some
standard Python packages.  For Windows platform, there is a pre-built executable
available~\cite{hsalrelabs}. 

The third component, namely the {\tt{SAL model checker}}, needs to be installed
separately~\cite{SAL-language}.  For Linux, pre-compiled executables are available
and for Windows, Cygwin is required.

\section{Running the Tool}

An XML dump of a Modelica model can be converted into SAL using the command:
\begin{quote}
 {\tt{modelica2sal  <filename.xml>}}
\end{quote}
The executable {\tt{modelica2sal}} is in the directory
{\tt{HSalROOT/bin}}, where {\tt{HSalROOT}} is the root directory where
the HybridSal tool is installed.
This commands performs both the first and second steps -- it first creates a 
HybridSal model and then creates a SAL abstraction for it.
It generates a SAL model.  The SAL model can be model checked as follows:
\begin{quote}
 {\tt{sal-inf-bmc -d 4 <filenameModel.sal> <propertyName>}}
\end{quote}
Here {\tt{<filenameModel.sal>}} is the file generated by the previous command above.
Inside the file {\tt{<filenameModel.sal>}}, there should be a property named
{\tt{<propertyName>}}.

There are two options for generating the property:
\begin{itemize}
\item The user can add the property by hand in the file {\tt{<filenameModel.sal>}}
that is created by {\tt{modelica2sal}}.
\item The property can be specified in JSON format and passed on as an argument to
the {\tt{modelica2sal}} tool:
\begin{quote}
 {\tt{modelica2sal  <filename.xml> <propertyFile.json>}}
\end{quote}
\end{itemize}

Rather than using Modelica XML dump as the starting point, the user
can build a HybridSal model by hand.  In that case, verification is performed
using the commands:
\begin{quote}
 {\tt{hsal2hasal  <filenameModel.hsal>}}
\\
 {\tt{sal-inf-bmc -d 4 <filenameModel.sal> <propertyName>}}
\end{quote}

Properties are of the form {\tt{G($\phi$)}}, which is read as
``in every reachable state of the system, the formula $\phi$ is true''.
For example, $\phi$ can be $x < 5$, where $x$ is a state variable in 
the model.

\section{Interpreting the Results}

The final output of the verification process, which is generated by the tool
 {\tt{sal-inf-bmc}}, is either an affirmative answer (saying that the property
is valid in the model), or a negative answer (saying that the property is
false in the model).  A negative answer is accompanied with a trace that shows
the violation of the property.

If the property is not true, the user can modify the model 
(initial states, values of certain parameters, constraints on inputs)
or the property  and re-verify.  The modification is done by directly
manipulating the HybridSal model (in the file {\tt{<filenameModel.hsal>}}).




\section{Caveats}

Verification of complex cyber-physical systems is a hard,
and in general an undecidable, problem.  
Hence verification tools are limited in various ways.
Verification using the HybridSal relational abstraction tool
can fail due to many reasons:
\begin{description}
\item[{\em{Nonlinearity}}]
The tool works only on linear hybrid systems.  Such systems can be
nonlinear -- but all nonlinearity should be in the form of ``mode changes''.
Within each mode, the dynamics have to be linear.
\item[{\em{State space representation}}]
The HybridSal modeling language represents the system in its state-space
form.  Modelica models contain plenty of non-state variables.
The modelica2hsal translater tries to eliminate the non-state variables
and create a HybridSal model.  But this process can fail due to many 
reasons, which causes failure of the verification process itself.
\end{description}

\bibliography{/homes/tiwari/ConfPapers/all}
\bibliographystyle{plain}

\appendix
\section{Detailed Example and the HybridSal Relational Abstractor Tool}

Consider a simple 2-dimensional continuous system defined by
\begin{eqnarray*}
\frac{dx}{dt} & = & -y + x
\\
\frac{dy}{dt} & = & -y - x
\end{eqnarray*}
Assume we are given the initial condition $x = 1, y = 2$
and the invariant that $y$ is always non-negative.
We wish to prove that $x$ always remains non-negative.

\begin{figure}[t]
\begin{tt}
\begin{verbatim}
Linear1: CONTEXT = 
BEGIN

control: MODULE =
BEGIN
 LOCAL x,y:REAL
 LOCAL xdot,ydot:REAL
 INITIALIZATION
  x = 1; y = 2
 TRANSITION
 [
 y >= 0 AND y' >= 0 --> 
  xdot' = -y + x ;
  ydot' = -y - x
 ]
END;

% proved using sal-inf-bmc -i -d 2 Linear1 helper
helper: LEMMA
 control |- G(0.9239 * x >= 0.3827 * y);

% proved using sal-inf-bmc -i -d 2 -l helper Linear1 correct
correct : THEOREM
 control |- G(x >= 0);
END
\end{verbatim}
\end{tt}
\caption{HybridSAL file describing a simple two-dimensional
continuous dynamical system, along with two safety
properties of that system.}\label{fig:hsal-ex}
\end{figure}

This example can be encoded in HybridSAL as shown in
Figure~\ref{fig:hsal-ex}.  The HybridSAL syntax is 
almost identical to the syntax of SAL~\cite{SAL-language}, but for a few
modifications that enable encoding of continuous dynamical
systems. The key changes in HybridSAL are:
\begin{itemize}
\item
Variables whose name ends in {\em{dot}} denote the derivative.
In Figure~\ref{fig:hsal-ex}, there are two state variables
$x,y$, and their derivatives are denoted by variables named
$xdot,ydot$ respectively.  These special dot variables can only
be used as left-hand sides of simple definitions (equations)
that appear in guarded commands.  Thus, the equation
$xdot' = -y+x$ denotes the differential equation
$dx/dt = -y+x$.
\item
The guard of the guarded command that encodes the system of
differential equation denotes the state invariant; that is,
the system is forced to remain inside the invariant set while
evolving as per the differential equations.
This meaning is consistent with the usual semantics of guards
in SAL. 
In Figure~\ref{fig:hsal-ex}, the guard $y \geq 0\wedge y'\geq 0$
says that $y\geq 0$ is the mode invariant for the only
mode in the system.
\end{itemize}
The definition of contexts, modules, and properties (theorems)
are exactly as in the SAL language~\cite{SAL-language}.

The user creates a HybridSAL model, similar to the one shown 
in Figure~\ref{fig:hsal-ex}, using a text editor.
Following the SAL convention for naming files, the HybridSAL file containing
the model in Figure~\ref{fig:hsal-ex} is stored as file
{\tt{Linear1.hsal}}.
Thereafter, to prove the two properties contained in 
{\tt{Linear1.hsal}}, the user executes the
following commands.
\begin{description}
\item[{\tt{bin/hsal2hasal examples/Linear1.hsal}}].
This command is run from
the root directory of the HybridSAL relational abstraction tool.
It will create a set of files in the subdirectory {\tt{examples/}},
including the file {\tt{Linear1.sal}} that contains the
relational abstraction of the original model.
The process of going from {\tt{Linear1.hsal}} to 
{\tt{Linear1.sal}} involves the following stages
(that are all performed in a single run of the above command):
\[
\begin{array}{rclclclcl}
{\tt{Linear1.hsal}} \longrightarrow
{\tt{Linear1.hxml}} \longrightarrow
{\tt{Linear1.haxml}} \longrightarrow 
{\tt{Linear1.xml}} \longrightarrow
{\tt{Linear1.sal}}
\end{array}
\]
The hsal2hxml converter is in the subdirectory 
{\tt{hybridsal2xml}}.  It is simply the HybridSAL
parser that parses a files and outputs it in {\tt{.hxml}} 
format.  The program {\tt{bin/hsal2hasal}} can take as input
either a {\tt{.hsal}} file or a {\tt{.hxml}} file.
It creates {\tt{.hasal}} and {\tt{.haxml}} -- which is 
a file in {\em{extended HybridSAL}} syntax -- that contains
the original model as well as its relational abstraction.
It is an intermediate file that is useful only for debugging
purposes at the moment.
In the last stage, the final {\tt{.xml}} and {\tt{.sal}} files 
are easily extracted
from the {\tt{.haxml}} files.
\item[{\tt{sal-inf-bmc -i -d 2 Linear1 correct}}].
Once the relational abstraction has been created, it can be 
model checked.  Note that the relational abstraction (in
file {\tt{Linear1.sal}}) is an {\em{infinite}} state system.
Hence, we can not use finite state model checkers. 
We can, however, use the SAL infinite bounded model checker
({\tt{sal-inf-bmc}}) and 
the k-induction prover
({\tt{sal-inf-bmc -i}}).
The k-induction prover can sometimes fail to prove a correct
assertion because the assertion is not inductive. In such a
case, auxiliary lemmas may be needed to complete a proof.
In the running example, we need a helper lemma.
Using the lemma {\tt{helper}}, the property {\tt{correct}}
can be proved using the command:
\\
 {\tt{sal-inf-bmc -i -d 2 -l helper Linear1 correct}}
\\
The lemma {\tt{helper}} can itself be proved using $k$-induction
as:
\\
 {\tt{sal-inf-bmc -i -d 2 Linear1 helper}}
\end{description}

This completes the discussion of the application of  the
HybridSAL relational abstraction tool on the running example.
For more complex examples, including examples of hybrid systems,
the reader is referred to the {\tt{examples/}} subdirectory in 
the tool.
We note a few points here.
\begin{description}
\item[Initialization]
The initial state of the system need not be a single point.
It can be a region of the state space.  For example,
in Figure~\ref{fig:hsal-ex}, 
the initialization section can be replaced by
the initialization 
\begin{tt}
 \begin{verbatim}
 INITIALIZATION 
  x IN {z:REAL|0 <= z AND z <= 1};
  y IN {z:REAL|2 <= z AND z <= 3};
 \end{verbatim}
\end{tt}
The new model can again be verified using the same set of commands
given above.
\item[Composition]
The model need not be a single module, and it can be a composition of 
modules.  Modules can be purely discrete -- they need not all have
dynamics given by differential equations.  For example, the example
in the File {\tt{TGC.hsal}} describes a model of the train-gate-controller
in HybridSAL that is a composition of five modules.  Only one of the
five has continuous differential equations in the dynamics.
\end{description}

Apart from the syntax for writing differential equations,
the HybridSAL input language supports two additional features
that are not part of the SAL language~\cite{SAL-language}.
These features are:
\begin{description}
\item[Invariant]
 Apart from {\tt{INITIALIZATION}} and {\tt{TRANSITION}} blocks,
 each basemodule can also have an {\tt{INVARIANT}} block.
 The invariant block contains a formula that is an (assumed)
 invariant of the system.
 
 In our running example, we can add the Invariant block:
 \begin{tt}
 \begin{verbatim}
  INVARIANT y >= 0
 \end{verbatim}
 \end{tt}
 in the basemodule, for example, just before/after the 
 {\tt{INITIALIZATION}} block.
 Then, we could replace the guard
 $y \geq 0 \wedge y'\geq 0$ by the new guard $\mathit{True}$
 in the (only) transition.
 If $\phi$ is declared as the invariant, then it has the
 effect of adding the formula $\phi \wedge \phi'$ in the guards
 of {\em{all}} transitions.  This is performed as a preprocessing
 step by the HSal Relational Abstractor.

\item[INITFORMULA]
 Instead of {\tt{INITIALIZATION}} block, a HybridSAL input file
 can contain a {\tt{INITFORMULA}} block that has a formula
 as the initialization predicate.
 
 In our running example, the initialization block shown above
 can be replaced by
 \begin{tt}
 \begin{verbatim}
  INITFORMULA 0 <= x AND x <= 1 AND 2 <= y AND y <= 3
 \end{verbatim}
 \end{tt}
 without changing the meaning of the HybridSAL model.

 The {\tt{INITFORMULA}} block is also handled during the
 preprocessing phase.
 The preprocessing phase also handles {\em{defined constants}}.
\end{description}

\section{HSal Relational Abstractor: Flags}

The HybridSAL Relational Abstractor tool accepts the following options/flags.
\begin{description}
\item[-n, --nonlinear]
 With this option, the tool creates a more precise relational abstraction,
 but it may be nonlinear.  Even when the input model is a linear
 continuous dynamical system, the output could be a nonlinear discrete
 time system.
 
 Currently, the SAL model checker can not analyze nonlinear discrete time
 systems.  Hence, this flag is useful only if using other backend tools
 that can handle discrete time nonlinear systems.

 By default, this option is {\em{not}} turned on, and the tool
 creates linear relational abstractions that can be analyzed by SAL
 infinite bounded model checker.

\item[-c, --copyguard]
 With this option, the tool explicitly handles the guard in the 
 continuous dynamics as state invariants.
 Recall the HybridSAL code for the differential equations
 $dx/dt = -y+x, dy/dt = -y-x$.
 \begin{tt}
 \begin{verbatim}
 [
 y >= 0 AND y' >= 0 --> 
  xdot' = -y + x ;
  ydot' = -y - x
 ]
 \end{verbatim}
 \end{tt}
 Here the guard $y \geq 0 \wedge y'\geq 0$ says that $y$ should be
 nonnegative both {\em{before}} and {\em{after}} the transition.
 In other words, $y\geq 0$ is the mode invariant.
 We could have written the same dynamics as follows:
 \begin{tt}
 \begin{verbatim}
 [
 y >= 0 --> 
  xdot' = -y + x ;
  ydot' = -y - x
 ]
 \end{verbatim}
 \end{tt}
 The new HybridSAL file, when processed with the flag {\tt{-c}},
 produces the same output as the original file would produce 
 without the {\tt{-c}} flag.
 Thus, the {\tt{-c}} flag causes copying of the guard 
 of the continuous transitions, but
 with variables replaced by their prime forms.

 By default, this option is {\em{not}} turned on, and the tool
 assumes that the input HybridSAL file already 
 contains guards on prime variables.

\item[-o, --opt]
 This flag turns on some optimizations in the relational
 abstractor.
 Currently, this flag causes the tool to construct a 
 relational abstraction that assumes that a certain amount
 of time is always spent in each mode.  This is an
 unsound assumption.  Hence, the output of the relational
 abstractor can be unsound when the {\tt{-o}} flag is used.
 
 The {\tt{-o}} flag is useful if the (sound) relational abstraction
 is too large to be analyzable (in reasonable time) by the model checker.
 In that case, the user could try to create a simpler, but unsound,
 abstraction using the {\tt{-o}} flag and model checking it.
 
 By default, this option is {\em{not}} turned on.

\item[-t $\langle$timestep$\rangle$, --time $\langle$timestep$\rangle$]
 This flag is still under development.
 It constructs  a timed relational abstraction of the given system.
 This is useful in cases where all discrete mode switches are
 {\em{time triggered}}.  The value of {\tt{timestep}} should be
 a real number, which is interpreted as the inverse of the
 sampling frequency.  It is important to choose the
 timestep carefully.
\end{description}

The tool is expected to include more options in the future
as new extensions and features are implemented.

\section{Background: HSal Relational Abstractor}

Hybrid dynamical systems are formal models of complex systems 
that have both discrete and continuous behavior.  
It is well-known that the problem of verifying hybrid systems for
properties such as safety and stability is quite
hard, both in theory and in practice.  There are no automated,
scalable and compositional tools and techniques for formal 
verification of hybrid systems.

HybridSAL is a framework for modeling and analyzing hybrid systems.
HybridSAL is built as an extension of SAL (Symbolic Analysis Laboratory).
SAL consists of a language and a suite of tools for modeling and 
analyzing discrete state transition systems.  HybridSAL extends SAL 
by allowing specification of continuous dynamics in the form of 
differential equations.
Thus, HybridSAL can be used to model hybrid systems.
These models can be abstracted into discrete  finite state transition
systems using the HybridSAL abstractor.  The abstracted system
is output in the SAL language, and hence SAL (symbolic) model 
checkers can be used to model check the abstraction.
While HybridSAL can be used to verify intricate hybrid system models,
it is based on constructing qualitative abstractions -- which can
be very coarse at times.  Furthermore, the HybridSAL abstractor is
not compositional, and can not abstract modules independently
separately without being very coarse.

To alleviate the shortcomings of the HybridSAL abstractor,
we developed the concept of relational abstractions of hybrid
systems.  A relational abstraction transforms a given hybrid system into
a purely discrete transition system by summarizing the effect
of the continuous evolution using relations.   The state space
of system and its discrete transitions are left unchanged. 
However, the differential equations describing the
continuous dynamics (in each mode) are replaced by a 
relation between the initial values of the variables and 
final values of the variables.
The abstract discrete system is an infinite-state system that can be
analyzed using standard techniques for verifying systems such
as $k$-induction and bounded model checking.

Relational abstractions can be constructed compositionally by 
abstracting each mode separately.  Abstraction and compositionality
are crucial for achieving scalability of verification.
We have also developed techniques for constructing good quality 
relational abstractions.  The details are technical and can be 
found in papers~\cite{ST11:CAV,Tiwari03:HSCC}.  The HybridSAL verification framework has 
been extended by an implementation of relational abstraction.



%\begin{verbatim}
%[1] Sriram Sankaranarayanan and Ashish Tiwari, 
   %"Relational Abstractions for Continuous and Hybrid Systems", In CAV 2011: 686-702. 
%
%[2] Ashish Tiwari, "Approximate Reachability for Linear Systems", In the 
 %Proceedings of Hybrid Systems: Computation and Control, HSCC 2003. 
%
%[3] http://www.csl.sri.com/users/tiwari/existsforall/
%
%[4] Ashish Tiwari, "Compositionally analyzing a PI controller family", 
  %In CDC 2011. To appear. 
%
%[5] Thomas Sturm and Ashish Tiwari, 
  %"Verification and synthesis using real quantifier elimination". In ISSAC 2011. 
%[Tiwari/03/Approximate] Ashish Tiwari,
 %"Approximate reachability for linear systems".
 %In HSCC 2003, pp. 514--525.
%
%[Fehnker+Ivancic/2004/Benchmarks] Ansgar Fehnker and Franjo Ivancic,
 %"Benchmarks for Hybrid Systems Verification". In HSCC 2004, pp. 326-341.
%\end{verbatim}

\end{document}
