\documentclass{llncs}
%\usepackage{sriram-macros}
\usepackage{url}
\usepackage{amsmath,amssymb,amsfonts}
%\usepackage{electComp}
\pagestyle{plain}

\title{HybridSAL Relational Abstraction}
%  \thanks{Tiwari's work supported in part by DARPA under Contract No. FA8650-10-C-7078,
%  NSF grants CSR-0917398 and SHF:CSR-1017483.}
\author{Ashish Tiwari}
\institute{SRI International, Menlo Park, CA.\ \url{ashish.tiwari@sri.com}}

\newif\iftrversion\trversionfalse
\def\linODEabs{\tt{linODEabs}}
\newcommand\ignore[1]{{}}
\newcommand\ite{{\mathtt{ite}}}
\newcommand\True{{\mathtt{True}}}
\newcommand\False{{\mathtt{False}}}

\begin{document}

\maketitle

\begin{abstract}
  We describe the relational abstraction component of the
  Meta Verification tool chain.
  Relational abstraction is a technique for verifying
  safety requirements.
  It does so by abstracting the given system, which could
  have a combination of continuous and discrete dynamics,  
  into a purely discrete system.
  The abstract discrete system is then analyzed using 
  automated verification techniques, such as model checking.
  The relational abstraction component consists of:
  \begin{itemize}
  \item a Modelica to HybridSal translator,
  \item HybridSal relational abstracter, and
  \item Sal infinite bounded model checker and k-induction prover.
  \end{itemize}
  This report describes these components, its strength and 
  limitations, and its use for safety verification.
\end{abstract}

\def\XX{\mathbb{X}}
\def\QQ{\mathbb{Q}}
\def\YY{\mathbb{Y}}
\def\RR{\mathbb{R}}
\def\ra{\rightarrow}
%\def\bra{{\crm{\ra}}}  % make it \ra_a
\def\bra{{\stackrel{a}{\ra}}}  % make it \ra_a
%\def\rra{{\cem{\ra}}}  % make it \ra_c
\def\rra{{\stackrel{c}{\ra}}}  % make it \ra_c

\section{Introduction}

  The HybridSal relational abstraction tool is
  part of the Meta verification tool chain.
  The relational abstraction component of the tool chain
  can verify safety properties of a system model.
  Safety properties state that the system always remains
  inside some safety bounds; or, in other words, the system
  never reaches an ``unsafe'' state.
  
  The systems being analyzed here are complex in at least two
  different ways. First, they are high dimensional; that is,
  their state is described by a large number of variables.
  Second, the dynamics of the system contain a combination of 
  both discrete and continuous behaviors.
  As a result, automated verification of such systems is challenging.
Relational abstraction is an approach for verification that addresses
this challenge by first constructing an abstraction of the system,
and then verifying safety properties on the abstract system.
Relational abstractions are often more precise than a purely
qualitative abstraction of the system, but they are still abstract
enough to enable tractable analysis using state exploration verification
tools.

The HybridSal relational abstraction tool has its own modeling 
language for hybrid dynamical systems, called the HybridSal language.
It extends the {\tt{SAL}} language, which was designed for modeling discrete state 
transition systems, with features that enable modeling of continuous
dynamical systems.  The HybridSal language has support for modeling
a system as a composition of subsystems, and supports nondeterminism
and symbolic parameter values.

For purposes of integration with the larger Meta verification tool box,
HybridSal also accepts Modelica models.
Specifically, the tool currently accepts as input the XML dump of the
flattened Modelica model generated by the OpenModelica compiler.
This frontend is implemented as a separable component of HybridSal,
called {\tt{modelica2hsal}}.
Due to time constraints and the richness of the Modelica language,
the {\tt{modelica2hsal}} tool can convert on a
limited subset of Modelica models into HybridSal.  
The {\tt{modelica2hsal}} tool, its features, and its limitations
are described in Section~\ref{sec-modelica2hsal}.

The HybridSal relational abstraction algorithm and implemention is
described in Section~\ref{sec-ra}.  We also describe the limitations
of the abstracter in that section.

The abstraction constructed by the HybridSal relational abstraction tool
is output as a {\tt{SAL}} model.  We briefly describe the SAL model
checking tools that can be used to analyze this abstract system 
in Section~\ref{sec-sal}.

% -------------------------------------------------------------------------
\section{{\tt{modelica2hsal}}: Converting Modelica to HybridSal}
\label{sec-modelica2hsal}

The {\tt{modelica2hsal}} tool converts a Modelica model into a HybridSal model.
The input to the tool is a file containing the XML dump of the
flattened Modelica model generated by the OpenModelica compiler.
The output of the tool is a file containing the HybridSal model.
The tool also takes a second optional argument, which is a file that contains
the context model and the requirement specification.
When the optional argument is provided, the {\tt{modelica2hsal}} tool automatically
includes the model of the context and the property in the generated HybridSal file.

The key technical difficulty in converting Modelica models into HybridSal models is
that Modelica represents models as a set of {\em{differential algebraic equations}} (DAEs),
whereas HybridSal represents systems as a collection of {\em{ordinary differential equations}}
with switching between them (switched ODEs).
In the process of converting DAEs into switched ODEs, one has to eliminate the
algebraic constraints in the DAEs.
There is no algorithmic procedure to achieve this goal.  There are heuristics 
based on simplifying the DAEs using different simplification rules.

The {\tt{modelica2hsal}} tool is implemented as follows:
\begin{enumerate}
\item  
Read the XML dump generated by Modelica 
\item
Output the DAEs in a .dae file
\item
Parse the .dae file and create a .daexml file
\item
Simplify the .daexml 
\item
Map the simplified .daexml into HybridSal model
\end{enumerate}
The main step in the translation is the simplification step above.
The {\tt{modelica2hsal}} tool currently implements several different
simplifications, including
\begin{description}
\item[Constant propagation:]  If a variable is known to have a fixed constant value,
then it is uniformly replaced by that value in the entire model and eliminated.
The constant propagation process can be written as the following rewrite rule:
\begin{eqnarray}
 x = c,  e[x]  & \rightarrow & e[x \mapsto c] 
\label{eqn-first}
\end{eqnarray}
where $e$ is any expression and $e[x\mapsto c]$ denotes the result of 
replacing $x$ by $c$ everywhere in $e$.
\item partial evaluation:  
If subexpressions can be evaluated as a result of constant propagation, then they
are evaluated and replaced by the computed value for them.  Application of
partial evaluation can result in more possibilities for constant propagation, and vice versa.
Some sample rewrite rules that describe partial evaluation are mentioned below:
\begin{eqnarray}
c1 + c2 & \rightarrow & c  \qquad \mbox{where $c$ is the sum of $c1$ and $c2$}
\\
0 * e & \rightarrow & 0
\\
0 + e & \rightarrow & e
\\
e - 0 & \rightarrow & e
\\
\ite(\True, e1, e2) & \rightarrow & e1
\\
\False \wedge e & \rightarrow & \False
\end{eqnarray}
\item[Term normalization:]
Expressions in the model are normalized using rewriting rules. For example,
$x + 2x + y$ is  normalized to $3x + y$, and $x + (-x)$ is normalized to $0$.
The Modelica expression language has ``if-then-else'' as a language construct.
Sometimes the different operating modes of the system are hidden inside such
``if-then-else'' expressions.
For example, the differential equation 
\begin{eqnarray*}
 \frac{dx}{dt} & = & \mbox{if c then e1 else e2}
\end{eqnarray*}
is a way to represent two modes: in one mode (when $c$ is true), $dx/dt = e1$,
and in the second mode (when $c$ is false), $dx/dt = e2$.
However, nested ``if-then-else'' expressions and combination of ``if-then-else'' expressions
with algebraic operators, such as $+, -, *$ make the problem of identifying modes more
difficult.
We use the following normalization rules for handling these cases:
\begin{eqnarray}
 \ite(c1,\ite(c2,e1,e2),e3) & \rightarrow & 
 \ite(c1\wedge c2,e1, \ite(c1 \wedge\neg c2, e2, e3))
\\
 \ite(c1,e1,e2) + e & \rightarrow & \ite(c1,e1+e,e2+e)
\\
 \ite(c1,e1,e2) - e & \rightarrow & \ite(c1,e1-e,e2-e)
\\
 \ite(c1,e1,e2) * e & \rightarrow & \ite(c1,e1*e,e2*e)
\\
 \ite(c1,e1,e2) / e & \rightarrow & \ite(c1,e1/e,e2/e)
\label{eqn-last}
\end{eqnarray}
Note that application of one rule can trigger application of others.
We apply all simplification and rewrite rules until they can be applied
no more.
\end{description}

The rewrite rules, Rule~(\ref{eqn-first})--Rule~(\ref{eqn-last}),
is not intended to be exhaustive list of all rules used by the
{\tt{modelica2hsal}} translator.  Its purpose is to just give an
idea of the simplification steps performed during the translation.

There are plenty of special rewrite rules to simplify and handle expressions
that are intrinsic to Modelica, such as,
\begin{enumerate}
\item set and set access:
\item computing cross product and dot product of two vectors
\item computing transpose of a matrix
\item user-defined interpolation function
\item arithmetic expressions over set terms
\item predefined functions, such as, $\mathtt{sqrt, abs, cos, sin, Real, noEvent, der}$
\end{enumerate}
Note that the simplification rules may not always be successful in eliminating 
certain functions; for example, $\sin$ can be eliminated (using the simplification
rewrite rules) if it is always applied to
a statically known constant (for e.g., $0$ or $\pi/2$), but it can not be eliminated in general.

An important step during the simplification phase is the step that replaces
(non fixed) variables by equivalent expressions.  This is a way to eliminate
algebraic constraints from the DAEs.
We take care not to eliminate {\em{state variables}}.  If we can generate
an expression $x = e$ by simplification, and $x$ is not defined to be a state variable,
we replace $x$ by $e$ everywhere in the Modelica model and eliminate $x$.

There are also additional simplification rules for handling tables,
and the interpolation function.
Essentially, a table is converted to a large ``if-then-else'' expression.


\subsection{Translating Simplified DAEs to HybridSal}

After the DAEs are simplified using the simplification rules described above,
the tool attempts to convert them into HybridSal.
The final HybridSal model is a {\em{synchronous composition}} of three different
base modules:
\begin{itemize}
\item a controller 
\item a plant 
\item a monitor
\end{itemize}
The property (requirement) are captured separately in the HybridSal file.
The context model is currently integrated into the HybridSal model.
Ideally, it should be implemented as a separate synchronously composed module
(like the monitor module).

The final conversion step is performed as follows:
\begin{enumerate}
\item
identify the variables that define the state space of the system
\item
identify the modes of the system
 % , predicates in conditionals
\item
create the controller module
\item
create the plant module
\item
create the monitor module
\end{enumerate}
The modes are identified  by collecting all predicates that occur in the 
``if-then-else'' expressions in the DAEs.

\paragraph{The controller module.}
Next, we generate the controller module.  The controller module updates
all discrete variables.  It is obtained from those equations in the
set of all DAEs that 
\\
(a) do not contain the derivative, {\tt{der}}, operator
\\
(b) can be written as $x = e$, and $x$ is a discrete state variable
\\
To guarantee the latter condition,  {\tt{modelica2hsal}} also implements
a symbolic equation solver.

The controller also makes sure that, in each step, some predicate 
(from the set of all predicates computed above) always changes.
% in each discrete step.

The feature of HybridSal that makes the translation possible is that
HybridSal allows two variants of each state variable in expressions --
{\bf{$x$ and $x'$}} --  $x$ is the previous value  and $x'$ is the value in the
next time step.  Modelica also uses two variants of each state variable:
$\mathtt{pre}(x)$ and $x$, with the same meaning. 

    % "find value for der(v) for all v in cstate; keep just ONE definition"

\paragraph{The plant module.}

The plant module is created from those equations in the system of DAEs that
\\
(a) contain the derivative, {\tt{der}}, operator
\\
(b) can be written as $der(x) = e$, where $x$ is a continuous state variable
\\
As mentioned before, all conditions that occur in if-then-else expressions
are collected and they define the modes of the system.  The plant HybridSal
module enumerates all modes of the system; and for each mode, it contains
a system of differential equations extracted from the DAEs.

Each HybridSal module also has an initialization block, where variables
can be initialized.  Initial values for variables are extracted from the
'initialValue' attribute of the variables in Modelica XML dump.
Some initialization equations are also extracted from the DAEs that contain
the 'initial' function in the expressions.

\paragraph{The monitor module.}
A separate HybridSal module is used to enforce that the system dynamics satisfy
some constraints.  Specifically, algebraic equations that can not be eliminated
by simplification and equation solving can be just monitored. 
The monitor module is {\em{synchronously composed}} with the rest of the system,
so if it can not make a step (because some constraint failed), then the whole
system deadlocks.
Monitors are also used to implement the context model.

\paragraph{Context and Property Modeling in HybridSal}

The {\tt{modelica2hsal}} tool takes an optional second argument that
is a file containing the context assumptions and the property to be proved
of the model.
This information can be provided in two different formats: either in 
XML format, or in JSON format.

% -------------------------------------------------------------------------
\section{HybridSal Relational Abstracter}\label{sec-ra}

A dynamical system $(\XX, \bra)$  with state space $\XX$ and
transition relation $\bra\subseteq \XX\times \XX$ 
is a {\em{relational abstraction}} of another 
dynamical system $(\XX, \rra)$ if
the two systems have the same state space and
$\rra \subseteq \bra$.
Since a relational abstraction contains all the behaviors of the
concrete system, it can be used to perform safety verification.

HybridSAL relational abstracter is a tool that computes a relational
abstraction of a hybrid system as described by
Sankaranarayanan and Tiwari~\cite{ST11:CAVsmall}.
A hybrid system $(\XX, \ra)$ is a dynamical system with 
\\
(a) state space $\XX := \QQ\times\YY$, where $\QQ$ is a finite set and
$\YY := \RR^n$ is the $n$-dimensional real space,
and 
\\
(b)
transition relation $\ra := \ra_{cont}\cup\ra_{disc}$, where
$\ra_{disc}$ is defined in the usual way using guards and
assignments, but $\ra_{cont}$ is defined by a system of
{\em{ordinary differential equation}} and a {\em{mode invariant}}.
One of the key steps in defining the (concrete)
semantics of hybrid systems
is relating a system of differential equation
$\frac{d\vec{y}}{dt} = f(\vec{y})$ with mode invariant
$\phi(\vec{y})$ to a binary relation 
over $\RR^n$, where $\vec{y}$ is a $n$-dimensional vector of
real-valued variables.  Specifically, the semantics of
such a system of differential equations is defined as:
\begin{eqnarray}
\vec{y}_0 \ra_{cont} \vec{y}_1 & &
\mbox{if}\;
\mbox{there is a $t_1\in\RR^{\geq 0}$ and 
a function $F$ from $[0,t_1]$ to $\RR^n$ s.t.} \nonumber %\label{eqn:sem}
\\ & &
\vec{y}_0 = F(0),
\vec{y}_1 = F(t_1), \mbox{ and } \nonumber
\\ & &
\forall{t\in [0,t_1]}:
\left(\frac{dF(t)}{dt} = f(F(t)) \wedge \phi(F(t))\right)\label{eqn:sem}
%
%\vec{y}_0 = F(0),
%\vec{y}_1 = F(t_1), \mbox{ and }
%\frac{dF(t)}{dt} = f(F(t)) \nonumber
%\\ & &
%\mbox{for some $t_1\in\RR^{\geq 0}$ and 
%some function $F$ from $[0,t_1]$ to $\RR^n$} \label{eqn:sem}
\end{eqnarray}
The concrete semantics is defined using the ``solution''
$F$ of the system of differential equations.  As a result,
it is difficult to work directly with it.

The relational abstraction of a hybrid system 
$(\XX, \rra_{cont}\cup\rra_{disc})$ 
is a discrete state transition system $(\XX, \bra)$ such that
$\bra = \bra_{cont}\cup\rra_{disc}$, where 
$\rra_{cont} \subseteq \bra_{cont}$.
In other words, the discrete transitions of the hybrid system
are left untouched by the relational abstraction, and only the
transitions defined by differential equations are abstracted.

The HybridSal relational abstracter tool computes such a relational
abstraction for an input hybrid system. 
In this paper, we describe the tool, the core algorithm implemented in the
tool, and we also provide some examples. % and case studies that
%are part of the tool distribution.

\subsection{Relational Abstraction of Linear Systems}

Given a system of linear ordinary differential equation,
$\frac{d\vec{x}}{dt} = A\vec{x}+\vec{b}$, we describe the
algorithm used to compute the abstract transition relation
$\bra$ of the concrete transition relation $\rra$ defined
by the differential equations.

The algorithm is described in Figure~\ref{fig:algo}.  
The input is a pair $(A,b)$, where
$A$ is a $(n\times n)$ matrix of rational numbers
and $\vec{b}$ is a $(n\times 1)$ vector of rational numbers.
The pair represents a system of differential equations
$\frac{d\vec{x}}{dt} = A\vec{x}+\vec{b}$.
The output is a formula $\phi$ over the variables
$\vec{x},\vec{x}'$ that represents the relational
abstraction of $\frac{d\vec{x}}{dt} = A\vec{x}+\vec{b}$.
The key idea in the algorithm is to use 
the eigenstructure of the matrix $A$ to generate the
relational abstraction.

\begin{figure}[htb!]
{\linODEabs}$(A,b)$:
{\em{Input}}: a pair $(A,b)$, where
$A\in\RR^{n\times n}, b\in\RR^{n\times 1}$.
\\
{\em{Output}}: a formula $\phi$ over the
variables $\vec{x},\vec{x}'$ 
\begin{enumerate}
\item
 identify all variables 
 $x_1, \ldots, x_k$ s.t. 
 $\frac{dx_i}{dt} = b_i$ where $b_i\in\RR\;\;\forall{i}$
\\
 %let $\phi_1$ be $\bigwedge_{i=2}^{k} \frac{x_i'-x_i}{b_i} = \frac{x_1'-x_1}{b_1}$
 let $E$ be $\{\frac{x_i'-x_i}{b_i} \mid i=1,\ldots,k\}$
\item
 partition the variables $\vec{x}$ into $\vec{y}$ and $\vec{z}$ s.t.
 $\frac{d\vec{x}}{dt} = A\vec{x}+\vec{b}$ can be rewritten as
 \begin{eqnarray*}
  \left[ \begin{array}{c} \frac{d\vec{y}}{dt} \\ \frac{d\vec{z}}{dt} \end{array} \right]
  & = &
  \left[ \begin{array}{cc} A_1 & A_2 \\ 0 & 0 \end{array} \right]
  \left[ \begin{array}{c} \vec{y} \\ \vec{z} \end{array} \right] +
  \left[ \begin{array}{c} \vec{b_1} \\ \vec{b_2} \end{array} \right]
 \end{eqnarray*}
 where 
  $A_1 \in \RR^{n_1\times n_1}$,
  $A_2 \in \RR^{n_1\times n_2}$,
  $\vec{b_1} \in \RR^{n_1\times 1}$, 
  $\vec{b_2} \in \RR^{n_2\times 1}$, and $n = n_1 + n_2$
\item set $\phi$ to be $\mathit{True}$
\item\label{loop1head}
 let $\vec{c}$ be a real left eigenvector of matrix $A_1$ and
 let $\lambda$ be the corresponding real eigenvalue, that is,
 %\begin{eqnarray*}
  $\vec{c}^T A_1 \; = \; \lambda \vec{c}^T$
 %\end{eqnarray*}
\item
 if $\lambda == 0\wedge c^TA_2 == 0$: set $E := E\cup \{ \frac{\vec{c}^T(\vec{y}'-\vec{y})}{\vec{c}^T\vec{b_1}} \}$; else: $E := E$
\item
 if $\lambda \neq 0$:
 define vector $\vec{d}$ and real number $e$ as:
  $\vec{d}^T   = {\vec{c}^T A_2}/{\lambda}$ and
  $e  = (\vec{c}^T \vec{b_1} + \vec{d}^T \vec{b_2})/{\lambda}$
 %\begin{eqnarray*}
  %\vec{d}^T  \; = \; \frac{\vec{c}^T A_2}{\lambda}
  % & \qquad &
  %e  \; = \; \frac{\vec{c}^T \vec{b_1} + \vec{d}^T \vec{b_2}}{\lambda}
 %\end{eqnarray*}
 \\
 let $p(\vec{x})$ denote the expression
 $\vec{c}^T\vec{y}+\vec{d}^T\vec{z}+e$
 and let $p(\vec{x}')$ denote
 $\vec{c}^T\vec{y}'+\vec{d}^T\vec{z}'+e$
 \\
 if $\lambda > 0$: set $\phi := 
  \phi \wedge [(p(\vec{x}') \leq p(\vec{x}) < 0)\vee
  (p(\vec{x}') \geq p(\vec{x}) > 0)\vee
  (p(\vec{x}') = p(\vec{x}) = 0)]
 $
 \\
 if $\lambda < 0$: set $\phi := 
  \phi \wedge 
 [(p(\vec{x}) \leq p(\vec{x}') < 0)\vee
  (p(\vec{x}) \geq p(\vec{x}') > 0)\vee
  (p(\vec{x}') = p(\vec{x}) = 0)]$
\item\label{loop1tail}
 if there are more than one eigenvectors corresponding to the eigenvalue $\lambda$, then update $\phi$ or $E$ by generalizing the above
\item
 repeat Steps~(\ref{loop1head})--(\ref{loop1tail}) 
 for each pair $(\vec{c},\lambda)$
 of left eigenvalue and eigenvector of $A_1$ 
\item\label{loop2head}
 let $\vec{c}+\imath\vec{d}$ be a complex left eigenvector
 of $A_1$ corresponding to eigenvalue $\alpha+\imath\beta$
\item
 using simple linear equation solving
 as above, find 
 $\vec{c_1}$, $\vec{d_1}$, $e_1$ and $e_2$ s.t.
 if $p_1$ denotes $\vec{c}^T\vec{y}+\vec{c_1}^T\vec{z}+e_1$
 and
 if $p_2$ denotes $\vec{d}^T\vec{y}+\vec{c_2}^T\vec{z}+e_2$
 then
 \begin{eqnarray*}
 \frac{d}{dt}(p_1)
  \; = \;
  \alpha p_1 - \beta p_2
 & \quad &
 \frac{d}{dt}(p_2)
  \; = \;
  \beta p_1 + \alpha p_2
  \end{eqnarray*}
 let $p_1'$ and $p_2'$ denote the primed versions of $p_1,p_2$
\item\label{loop2tail}
 if $\alpha \leq 0$: set $\phi := \phi\wedge( p_1^2+p_2^2 \geq
 {p_1'}^2 + {p_2'}^2)$
 \\
 if $\alpha \geq 0$: set $\phi := \phi\wedge( p_1^2+p_2^2 \leq
 {p_1'}^2 + {p_2'}^2)$
\item
 repeat Steps~(\ref{loop2head})--(\ref{loop2tail}) for every
 complex eigenvalue eigenvector pair
\item
 set $\phi := \phi\wedge
 \bigwedge_{e_1,e_2\in E} e_1 = e_2;\;\;$ return $\phi$
\end{enumerate}
\caption{Algorithm implemented in HybridSal relational abstracter
for computing relational abstractions of linear ordinary differential
equations.}\label{fig:algo}
\end{figure}

The following proposition states the correctness of the algorithm.
\begin{proposition}\label{prop:corr}
Given $(A,b)$, let $\phi$ be the output of 
procedure {\linODEabs} in
Figure~\ref{fig:algo}.
If $\ra_{cont}$ is the binary relation defining the
semantics of $\frac{d\vec{x}}{dt} = A\vec{x}+b$ 
with mode invariant $\mathit{True}$
(as defined in Equation~\ref{eqn:sem}), then
$\ra_{cont}  \;\subseteq\; \phi$.
\end{proposition}
%\ignore{
\begin{proof}(Sketch)
First, let $p(\vec{x})$ be the linear expression
$\vec{c}^T\vec{y}+\vec{d}^T\vec{z}+e$ discovered in Step~(6).
Then,
\begin{eqnarray*}
\frac{dp}{dt} &=& \vec{c}^T(A_1\vec{y}+A_2\vec{z}+\vec{b_1}) +
 \vec{d}^T\vec{b_2}
\; = \; \lambda\vec{c}^T\vec{y}+\lambda\vec{d}^T\vec{z}+\vec{c}^T\vec{b_1} + \vec{d}^T\vec{b_2}
\\
& = & \lambda*(\vec{c}^T\vec{y}+\vec{d}^T\vec{z}+\vec{c})
\; = \; \lambda*p
\end{eqnarray*}
Hence, $p(\vec{x}(t)) = p(\vec{x}(0)) e^{\lambda t}$.
Therefore, the relation added in Step~(6) to $\phi$ 
will hold between an initial state $\vec{x}$ and a future
state $\vec{x'}$.

Next, consider the quadratic relations added to $\phi$ 
in Step~(11).  Let $p_1,p_2$ be as defined in Step~(10).
Then,
\begin{eqnarray*}
\frac{d(p_1^2+p_2^2)}{dt} 
& = &
 2p_1(\alpha p_1-\beta p_2)+2p_2(\beta p_1+\alpha p_2)
\; = \;
 2\alpha(p_1^2 + p_2^2)
\end{eqnarray*}
Hence, 
$p_1(\vec{x}(t))^2+p_2(\vec{x}(t))^2 = 
 (p_1(\vec{x}(0))^2+p_2(\vec{x}(0))^2) e^{2\alpha t}$,
and therefore, the relation added in Step~(11) to $\phi$
will hold between an initial state $\vec{x}$ and a future
state $\vec{x'}$.

Finally, consider the relations added in Step~(13).
It is easy to observe that every expression $s(\vec{x},\vec{x'})$ 
in the set $E$ is equal to the time $t$ taken to reach $\vec{x}'$
from $\vec{x}$ following the linear ODE dynamics.
Hence, all these expressions need to be equal, as stated in Step~(13).
\qed
\end{proof}
%\endignore}

By applying the above abstraction procedure on to the
dynamics of each mode of a given hybrid system,
the HybridSal relational abstracter constructs  a
relational abstraction of a hybrid system.
This abstract system is a purely discrete 
infinite state space system that can be analyzed
using infinite bounded model checking (inf-BMC), 
k-induction, or abstract interpretation.

We make two important remarks here.
First,
the relational abstraction constructed by 
procedure {\linODEabs} is a Boolean combination
of linear {\em{and nonlinear}} expressions.
The nonlinear expressions can be replaced by their
conservative linear approximations.  The
HybridSal relational abstracter performs this approximation
by default.  It generates the (more precise)
nonlinear abstraction (as described in Figure~\ref{fig:algo})
when invoked using an appropriate command line flag.
Both inf-BMC and k-induction
provers rely on satisfiability modulo theory (SMT) solvers.
Most SMT solvers can only reason % with Boolean combination of 
about {\em{linear}} constraints, and hence, the ability to
generate linear relational abstractions is important.
However, there is significant research effort going on
into extending SMT solvers to handle nonlinear expressions.
HybridSal relational abstracter and SAL inf-BMC 
have been used to create benchmarks for 
linear {\em{and nonlinear}} SMT solvers.

Second, Procedure {\linODEabs} can be extended to
generate even more precise {\em{nonlinear}}
relational abstractions of linear systems.
Let $p_1, p_2, \ldots, p_k$ be $k$ (linear and nonlinear)
expressions found by Procedure {\linODEabs} that 
satisfy the equation $\frac{dp_i}{dt} = \lambda_i p_i$.
Suppose further that 
there is some $\lambda_0$ s.t.
for each $i$
$\lambda_i = n_i \lambda_0$ for some {\em{integer}} $n_i$.
Then, we can extend $\phi$ by adding the following relation to it:
\begin{eqnarray}
 p_i(\vec{x}')^{n_j} p_j(\vec{x})^{n_i}
 & = & p_j(\vec{x}')^{n_i}  p_i(\vec{x})^{n_j}
\label{eqn:nl}
\end{eqnarray}
%\ignore{
The above relationship holds for any binary reachable
pair of states $(\vec{x},\vec{x'})$ 
because
$$
 \left(\frac{p_i(\vec{x}')}{p_i(\vec{x})}\right)^{n_j} 
 = 
 \left(\frac{p_j(\vec{x}')}{p_j(\vec{x})}\right)^{n_i} 
 =
 e^{n_in_j\lambda_0 t}
$$
%\endignore}
However, since $p_i$'s are linear or quadratic 
expressions, the above relations will be highly
nonlinear unless $n_i$'s are small.  So, they are
not currently generated by the relational abstracter.
It is left for future work to see if good and useful
linear approximations of these highly nonlinear relations
can be obtained.

\subsection{The HybridSal Relational Abstracter Tool}

The HybridSal relational abstracter tool, including
the sources, documentation and examples, is freely available
for download~\cite{hsalrelabs}.
% from {\url{http://www.csl.sri.com/~tiwari/}}.
% The tool directory contains the sources as well as
% documentation  and examples.

The input to the tool is a file containing a 
specification of a hybrid system and safety
properties.  The HybridSal language naturally
extends the SAL language by providing syntax for
specifying ordinary differential equations.
SAL is a guarded command language for specifying
discrete state transition systems and supports
modular specifications using synchronous and
asynchronous composition operators.  The reader
is referred to~\cite{SAL-language} for details.
HybridSal inherits all the language features of
SAL.  Additionally, HybridSal allows 
differential equations to appear in the model as follows:
for each real-valued variable $x$, the user 
defines a dummy variable $xdot$
which represents $\frac{dx}{dt}$.  A differential
equation can now be written by assigning to
the $xdot$ variable.
Assuming two variables $x,y$, the syntax is as follows:
\begin{quote}
\begin{tt}
 guard(x,y) AND guard2(x,x',y,y') --> xdot' = e1; ydot' = e2
\end{tt}
\end{quote}
This represents the system of differential equations
$\frac{dx}{dt} = e1, \frac{dy}{dt} = e2$ with
mode invariant $\mathit{guard}(x,y)$.
The semantics of this guarded transition is the binary
relation defined in Equation~\ref{eqn:sem} conjuncted with
the binary relation $\mathit{guard2}(x,x',y,y')$.
The semantics of all other constructs in HybridSal match
exactly the semantics of their counterparts in SAL.

Figure~\ref{fig:ex} contains sketches of two examples of 
hybrid systems modeled in HybridSal.
The example in Figure~\ref{fig:ex}(left) defines a module
{\tt{SimpleHS}} with two real-valued variables $x,y$.  Its 
dynamics are defined by % differential equations 
$\frac{dx}{dt}=-y+x$, $\frac{dy}{dt}=-y-x$ with mode
invariant $y \geq 0$, and by a 
discrete transition with guard % that resets the value of $x$ and $y$ when
$y \leq 0$.
The HybridSal file {\tt{SimpleHS.hsal}} also defines 
two safety properties. The latter
one says that $x$ is always non-negative.
This model is analyzed by abstracting it 
\\ \indent
%\begin{quote}
 {\tt{ bin/hsal2hasal examples/SimpleEx.hsal}}
%\end{quote}
\\ \noindent
to create a relational abstraction in 
a SAL file named {\tt{examples/SimpleEx.sal}},
and then (bounded) model checking the SAL file
%\begin{quote}
\\ \indent
 {\tt{ sal-inf-bmc -i -d 1 SimpleEx helper}}
\\ \indent
 {\tt{ sal-inf-bmc -i -d 1 -l helper SimpleEx correct}}
\\ \noindent
%\end{quote}
The above commands prove the safety property using $k$-induction:
first we prove a lemma, named {\tt{helper}}, using 1-induction and then
use the lemma to prove the main theorem named {\tt{correct}}.

The example in Figure~\ref{fig:ex}(right) shows the sketch of
a model of the train-gate-controller example in HybridSal.
All continuous dynamics are moved into one module (named
{\tt{timeElapse}}).  The 
{\tt{train}},
{\tt{gate}} and
{\tt{controller}} modules define the state machines and are
pure SAL modules.
The {\tt{observer}} module is also a pure SAL module
and its job is to enforce synchronization between
modules on events.
The final system is a complex composition of the base modules.

\begin{figure}[htb!]
\begin{tt}
\begin{tabular}{ll}
\begin{minipage}{2in}
\begin{tabbing}
S\=impleEx: CONTEXT = BEGIN
\\ \>
S\=impleHS: MODULE = BEGIN
\\ \> \>
LOCAL x,y,xdot,ydot:REAL
\\ \> \>
I\=NITIALIZATION
\\ \> \> \>
  x = 1; y IN \{z:REAL| z <= 2\}
\\ \> \>
T\=RANSITION
\\ \> \> \>
$[$
y \= >= 0 AND y' >= 0 --> 
\\ \> \> \> \>
  xdot' = -y + x ;
\\ \> \> \> \>
  ydot' = -y - x
\\ \> \> \>
$[]$
y <= 0 --> x' = 1; y' = 2$]$
\\ \>
END;
\\ \>
he\=lper: LEMMA SimpleHS |- 
\\ \> \> G(0.9239*x >= 0.3827*y);
\\ \>
% proved using sal-inf-bmc -i -d 2 -l helper Linear1 correct
co\=rrect : THEOREM
\\ \>\>
SimpleHS |- G(x >= 0);
\\
END
\end{tabbing}
\end{minipage}
&
\begin{minipage}{2in}
% Train gate controller
\begin{tabbing}
T\=GC: CONTEXT = BEGIN
\\ \>
Mode: TYPE = \{s1, s2, s3, s4\};
\\ \>
t\=imeElapse: MODULE = BEGIN
\\ \> \>
 {\em{variable declarations}}
% \\
 % LOCAL xdot, ydot, zdot: REAL
% \\
 % INPUT s, g, c: Mode
% \\
 % INPUT lower, exit, raise, approach: BOOLEAN
\\ \> \>
 INITIALIZATION x = 0; y = 0; z = 0 
\\ \> \>
 T\=RANSITION
\\ \> \> \>
$[${\em{m}}\={\em{ode invariants}} -->
 % ((s = s1 AND exit = FALSE) OR
% \\
  % (s = s2 AND approach = FALSE AND x <= 5 AND x' <= 5)) AND
% \\
 % ((g = s2 AND y <= 1 AND y' <= 1) OR
% \\
  % (g = s3 AND y <= 2 AND y' <= 2) OR (g = s1)) AND
% \\
 % ((c = s2 AND z <= 1 AND z' <= 1) OR
% \\
  % (c = s3 AND lower = FALSE) OR 
% \\
  % (c = s4 AND z <= 1 AND z' <= 1) OR
% \\
  % (c = s1 AND raise = FALSE)) AND
% \\
 % (x' >= x + 1/2) AND
% \\
 % (x >= 0 AND y >= 0 AND z >= 0 AND x' >= 0 AND y' >= 0 AND z' >= 0)
\\ \> \> \> \>
 --> xdot' = 1; ydot' = 1; zdot' = 1$]$
\\ \>
END;
\\ \>
train: MODULE = $\ldots$
%\\
%BEGIN
%\\
  %GLOBAL/OUTPUT declarations
%% approach, exit: BOOLEAN
%%\\
  %%GLOBAL x: REAL
%%\\
  %%OUTPUT s: Mode
%\\
  %INITIALIZATION  s = s1; $\ldots$ %approach = FALSE; exit = FALSE
%\\
  %TRANSITION
%\\
  %$[$
%\\
  %s = s1 --> s' = s2; $\ldots$ % approach' = TRUE; x' = 0
%\\
  %$[]$
%\\
  %%s = s2 AND approach = FALSE AND x > 2 --> $\ldots$ %exit' = TRUE; s' = s1
%\\
  %$]$
%\\
%END ;
%\\
\\ \>
gate: MODULE = $\ldots$
% \\
% BEGIN
% \\
  % GLOBAL/OUTPUT declarations
  % % GLOBAL lower, raise: BOOLEAN
% % \\
  % % GLOBAL y: REAL
% % \\
  % % OUTPUT g: Mode
% \\
  % INITIALIZATION  g = s1
% \\
  % TRANSITION
% \\
  % $[$
  % g = s1 AND lower = TRUE 
% \\
 % --> lower' = FALSE; g' = s2; y' = 0
% \\
  % $[] \ldots [] \ldots ]$
% %\\
  % %g = s2 AND raise = TRUE --> g' = s3; raise' = FALSE; y' = 0
% %\\
  % %[]
% %\\
  % %g = s3 AND y >= 1 --> g' = s1
% %\\
  % %]
% \\
% END ;
%\\
\\ \>
controller: MODULE = $\ldots$
% \\
% BEGIN
% \\
  % GLOBAL/OUTPUT declarations
% % lower, raise, approach, exit: BOOLEAN
% %\\
  % %GLOBAL z: REAL
% %\\
  % %OUTPUT c: Mode
% \\
  % INITIALIZATION  c = s1; $\ldots$ % lower = FALSE; raise = FALSE
% \\
  % TRANSITION
% \\
  % $[$
% \\
  % c = s1 AND raise = FALSE AND approach = TRUE 
% \\
  % --> approach' = FALSE; c' = s2; z' = 0
% % \\
  % % $[]$
% % \\
  % % c = s2 AND z = 1 --> c' = s3; lower' = TRUE
% \\
  % $[] \ldots [] \ldots [] \ldots ]$
% %\\
  % %c = s3 AND lower = FALSE AND exit = TRUE --> c' = s4; z' = 0; exit' = FALSE
% %\\
  % %[]
% %\\
  % %c = s4 --> c' = s1; raise' = TRUE
% %\\
  % %]
% \\
% END;
%\\
\\ \>
observer: MODULE = $\ldots$
%\\
%BEGIN
%\\
  %INPUT lower, raise, approach, exit: BOOLEAN
%\\
  %TRANSITION
%\\
  %$[$
%\\
  %NOT(lower AND lower') AND NOT(raise AND raise') AND 
%\\
  %NOT(approach AND approach') AND NOT(exit AND exit') -->
%\\
  %$]$
%\\
%END;
%\\
\\ \>
sy\=stem: MODULE = (observer || (train []
\\ \> \>
  gate [] controller [] timeElapse));
%\\
\\ \>
% sal-inf-bmc -i -ice -d 10  TGC correct
% The gate is down (g = s2) when the train is on the intersection (s = s2)
co\=rrect: THEOREM system |- G ( ... ) ;
% \\ \> \>
  % G( (s = s2 AND x >= 2) => g = s2 ) ;
%
% The gate is always closed: This is false
%\\
%canreach: THEOREM
%\\
  %system |- G( g = s2 ) ;

% The gate is always open: This is false
%\\
%canreach1: THEOREM
%\\
  %system |- G( g = s1 OR g = s3) ;
%
%
\\
END
\end{tabbing}
\end{minipage}
%& 
%\begin{minipage}{2in}
%\end{minipage}
\end{tabular}
\end{tt}
\caption{Modeling hybrid systems in HybridSal: A few examples.}
\label{fig:ex}
\end{figure}

The above two examples, as well as,
several other simple examples are provided in the
HybridSal distribution to help
users understand the syntax and working of the
relational abstracter.  
A notable (nontrivial) example in the distribution is a hybrid
model of an automobile's automatic transmission from~\cite{ChutinanButts02:Mobies}.
Users have to separately
download and install SAL model checkers if they
wish to analyze the output SAL files using
k-induction or infinite BMC.

The HybridSal relational abstracter constructs abstractions
compositionally; i.e., it works on each mode 
(each system of differential equations) separately.
It just performs some simple linear algebraic manipulations
and is therefore very fast.  
% The input HybridSal (.hsal) file is parsed into an XML (.hxml)
% file, and the tool works by replacing the XML elements 
% (in the XML DOM) representing
% the continuous differential equations by new XML elements 
% representing the relational abstraction. This creates a 
% SAL XML file (.xml), which is pretty printed into a SAL (.sal) file. 
The bottleneck step in our tool chain
is the inf-BMC and k-induction step,
which is orders of magnitude slower than the abstraction step
(we have not tried abstract interpretation yet).
The performance of HybridSal matches the performance reported 
in our earlier paper~\cite{ST11:CAVsmall} on the navigation
benchmarks (which are included with the HybridSal distribution).
In~\cite{ST11:CAVsmall} we had used many
different techniques (not all completely automated at that time)
to construct the relational abstraction.

\subsection{Strengths and Limitations}

The HybridSal relational abstracter is a tool for verifying
hybrid systems.  The other common tools for hybrid
system verification consist of 
(a) tools that iteratively compute
an overapproximation of the reachable states~\cite{SpaceExsmall},
(b) tools that directly search for correctness certificates
(such as inductive invariants or Lyapunov function)~\cite{sostools,ST11:ISSACsmall},
or
(c) tools that compute an abstraction and then analyze
the abstraction~\cite{HybridSALsmall,AlurDangIvancic03:TACASsmall,Clarke03:TACASsmall}.
Our relational abstraction tool falls in category~(c), but unlike all
other abstraction tools, it does
not abstract the state space, but abstracts only the transition relation.
 
The key benefit of relational abstraction
is that it cleanly separates reasoning on continuous
dynamics (where we use control theory or systems theory)
and
reasoning on discrete state transition systems (where we use 
formal methods.)
% The former is used for constructing high quality relational abstractions
% and the latter is used for verifying the abstract system.
Concepts such as Lyapunov functions or inductive invariants
(aka barrier certificates) for continuous systems are used
to construct very precise relational abstractions, and
formal methods is used to verify the abstracted system.
In fact, for several classes of simple continuous dynamical systems, 
lossless relational abstractions can be constructed, and hence
all incompleteness in verification then comes from incompleteness
of verification of infinite state transition systems. %k-induction provers.

%When the relational abstraction is analyzed using 
%the k-induction prover or inf-BMC,
%we generate large SMT formulas containing linear and nonlinear
%arithmetic with Booleans connectives and other finite datatypes.
%These instances can serve as benchmarks for SMT provers.
%The scalability of verification is now strictly tied to the
%scalability of SMT solving.

We note that our tool is the first in its space and is still
under active development.  We hope to
enhance the tool in some of the following ways 
% to address several of following shortcomings
in the future. % releases of the tool.
% The relational abstraction methodology and tool have certain
% weaknesses, which we now enumerate.  
(a) Relational abstraction generates verification 
problem on a discrete, infinite state space system, which are difficult to
verify automatically.  
Nevertheless, dedicated methods for generating 
invariants and for performing abstract interpretation can be developed
that are tailored to analyzing relational abstractions.
% There is a need to develop 
% The use of k-induction can require the need for auxiliary lemmas.  
% The SMT formulas generated can be very large.
(b) More precise relational abstractions can be potentially generated
by using mode invariants.
% Our tool does not use the mode invariants when creating
% relational abstractions.  % The use of mode invariants can lead to
% discovery of more relational invariants.  
(c) Numerical errors due to floating point arithmetic need
to be handled properly.
% can be eliminated
% by and hence the computed eigenvalues and eigenvectors
% can have numerical errors.  
(d) Other techniques for discovering relational
invariants can be included to complement the current procedure.
% that are not automated in our tool presently.
(e) Support for nonlinear differential equations is required to
analyze more complex hybrid models.
% Our tool % is restricted to handling linear differential equations.  % It
% can not handle nonlinear differential equations presently.
(f) We also need support to efficiently handle platform constraints
imposed on control systems, such as sampling frequency, 
sensing and actuation delays, etc~\cite{ZST12:CAV}.% .  The theory of 


\section{The SAL Model Checking Tools}


\section{Drivetrain Case Study}

In this section, we present the HybridSAL model of the drivetrain case study.
The drivetrain was originally modeled in Modelica. 
The Modelica file was translated by hand into a HybridSAL model
shown in Figure~\ref{fig:1} and Figure~\ref{fig:2}.

We briefly describe the
HybridSAL models in Figure~\ref{fig:1} and Figure~\ref{fig:2}.
First, note that the drivetrain {\tt{system}} is modeled as a composition
of two submodules, namely {\tt{plant}} and {\tt{control}}.
This is captured in Figure~\ref{fig:2} as:
\begin{quote}
\begin{tt}
system: MODULE  = plant || control ;
\end{tt}
\end{quote}
Figure~\ref{fig:1} contains the description of module {\tt{plant}}
and 
Figure~\ref{fig:2} contains the description of module {\tt{control}}.


\begin{figure}[htb!]
\begin{tt}
\begin{tabbing}
drivetrain: CONTEXT = 
\\
BEGIN
\\
% e11new = e11old / 10000
plant: MODULE =
\\
BEGIN
\\
OUTPUT f5, f7, e11, f17:REAL
\\
INPUT ratio: REAL
\\
INI\=TIALIZATION
\\ \>
  f5 = 0; f7 = 0; e11 = 0; f17 = 0
\\
TRANSITION
\\
\mbox{[}
\\
rat\=io = 1/4 AND (ratio' = 1/3 OR ratio' = 1) -->
\+
\\ 
  f5dot' = e11*10000/2400 - f5/20 ;
\\
  f7dot' = 40 + 20 * f17 - 20 * f7 ;
\\
  e11dot' = f17 * 1000 * 1/4 - f5 * 10000/6 ;
\\
  f17dot' = 100*f7 - 100*f17 - e11* 10000/40
\-
\\ 
 \mbox{[]}
\\ 
rat\=io = 1/3 AND (ratio' = 1/3 OR ratio' = 3/7) --> 
\\ \>
  f5dot' = e11*10000/2400 - f5/20 ;
\\ \>
  f7dot' = 40 + 20 * f17 - 20 * f7 ;
\\ \>
  e11dot' = f17 * 1000 * 1/3 - f5 * 10000/6 ;
\\ \>
  f17dot' = 100*f7 - 100*f17 - e11* 10000/30
\\
 \mbox{[]}
\\
ratio = 3/7 AND (ratio' = 1/3 OR ratio' = 3/5) --> 
\\ \>
  f5dot' = e11*10000/2400 - f5/20 ;
\\ \>
  f7dot' = 40 + 20 * f17 - 20 * f7 ;
\\ \>
  e11dot' = f17 * 1000 * 3/7 - f5 * 10000/6 ;
\\ \>
  f17dot' = 100*f7 - 100*f17 - e11*10000* 3/70
\\
 \mbox{[]}
\\
ratio = 3/5 AND (ratio' = 3/7 OR ratio' = 1) --> 
\\ \>
  f5dot' = e11*10000/2400 - f5/20 ;
\\ \>
  f7dot' = 40 + 20 * f17 - 20 * f7 ;
\\ \>
  e11dot' = f17 * 1000 * 3/5 - f5 * 10000/6 ;
\\ \>
  f17dot' = 100*f7 - 100*f17 - e11*10000* 3/50
\\
 \mbox{[]}
\\
ratio = 1 AND (ratio' = 3/5 OR ratio' = 7/5) --> 
\\ \>
  f5dot' = e11*10000/2400 - f5/20 ;
\\ \>
  f7dot' = 40 + 20 * f17 - 20 * f7 ;
\\ \>
  e11dot' = f17 * 1000 * 1 - f5 * 10000/6 ;
\\ \>
  f17dot' = 100*f7 - 100*f17 - e11* 10000/10
\\
 \mbox{[]}
\\
ratio = 7/5 AND ratio' = 1 --> 
\\ \>
  f5dot' = e11*10000/2400 - f5/20 ;
\\ \>
  f7dot' = 40 + 20 * f17 - 20 * f7 ;
\\ \>
  e11dot' = f17 * 1000 * 7/5 - f5 * 10000/6 ;
\\ \>
  f17dot' = 100*f7 - 100*f17 - e11*10000* 7/50
\\
 \mbox{]}
\\
END;
\end{tabbing}
\end{tt}
\caption{HybridSAL model of the drivetrain case study. The {\tt{plant}} module describes the
dynamics of the physical plant. The rest of the HybridSAL model is shown in Figure~\ref{fig:2}.}
\label{fig:1}
\end{figure}

The state space of the {\tt{plant}} module is described by four real-valued variables,
f5, f7, f17 and e11. 
Note that, in the original Modelica model, these variables had appeared within the derivative
({\tt{der}}) operator.
All the other variables in the Modelica model were eliminated during the translation
to HybridSAL.
The {\tt{plant}} module has as input the variable {\tt{ratio}}.
The {\tt{control}} module outputs (writes) {\tt{ratio}} and the {\tt{plant}} module inputs (reads) it.
Similarly,
the {\tt{control}} module reads the value of {\tt{f5}} and {\tt{f17}}, whereas
the {\tt{plant}} module writes it.
After the variable declarations, a HybridSAL module has two other important declarations:
{\tt{Initialization}} and {\tt{Transition}} sections.
All state variables are initialized to zero thus,
\begin{quote}
\begin{tt}
INITIALIZATION f5 = 0; f7 = 0; e11 = 0; f17 = 0
\end{tt}
\end{quote}

In the {\tt{Transition}} section, we give one set of ordinary differential equations (ODEs)
for each mode of the system. A set of ODEs consists of a differential equation for each
of the four variables. Since ratio can take six different values, there are six modes
and six sets of ODEs in the module {\tt{Plant}}.
The formula before the {\tt{-->}} in a guarded command is a guard that specifies what
condition must hold at the beginning (unprimed variables) and at the end 
(primed variables) of the transition.
For example, the differential equations describing the plant when {\tt{ratio}} is 1/4 
is written as
\begin{quote}
\begin{tt}
\begin{tabbing}
rat\=io = 1/4 AND (ratio' = 1/3 OR ratio' = 1) -->
\+
\\ 
  f5dot' = e11*10000/2400 - f5/20 ;
\\
  f7dot' = 40 + 20 * f17 - 20 * f7 ;
\\
  e11dot' = f17 * 1000 * 1/4 - f5 * 10000/6 ;
\\
  f17dot' = 100*f7 - 100*f17 - e11* 10000/40
\end{tabbing}
\end{tt}
\end{quote}
The guard captures the fact that if ratio is $1/4$ now, it will either
be $1/3$ or $1$ in the {\em{next}} step.
This forces a transition to necessarily change {\tt{ratio}}
in each step.

\begin{figure}
\begin{tt}
\begin{tabbing}
control: MODULE =
\\
BEGIN
\\
OUTPUT ratio: REAL
\\
LOCAL G1, G2, G3, G4, G5, G6: REAL
\\
LOCAL G2Low, G3Low, G4Low, G5Low, G6Low: REAL
\\
LOCAL G1High, G2High, G3High, G4High, G5High, G6High: REAL
\\
INPUT f17, f5: REAL
\\
LOCAL OutRPM: REAL
\\
INITIALIZATION ratio = 1/4
\\
DEF\=INITION G1 = 1/4; G2 = 1/3; G3 = 3/7; G4 = 3/5; G5 = 1; G6 = 7/5;
\\ \>
 G2Low = G1High; 
 G3Low = G2High; 
\\ \>
 G4Low = G3High; 
 G5Low = G4High; 
\\ \>
 G6Low = G5High; 
\\ \>
 G1High = G1 * 1800;
 G2High = G2 * 1800;
\\ \>
 G3High = G3 * 1800;
 G4High = G4 * 1800;
\\ \>
 G5High = G5 * 1800;
 G6High = G6 * 1800;
\\ \>
 OutRPM = f5 * 16
\\
TRA\=NSITION
\\
$[$
\\  \>
 OutRPM' < G1High --> ratio' = G1
\\ \>
 []
\\ \>
 OutRPM' >= G2Low AND OutRPM' < G2High --> ratio' = G2
\\ \>
 []
\\ \>
 OutRPM' >= G3Low AND OutRPM' < G3High --> ratio' = G3
\\ \>
 []
\\ \>
 OutRPM' >= G4Low AND OutRPM' < G4High --> ratio' = G4
\\ \>
 []
\\ \>
 OutRPM' >= G5Low AND OutRPM' < G5High --> ratio' = G5
\\ \>
 []
\\ \>
 OutRPM' >= G6Low AND OutRPM' < G6High --> ratio' = G6
\\ \>
 []
\\ \>
 ELSE --> ratio' = 1
\\
]
\\
END;
\\

\\
system:MODULE  = plant || control ;
\\

\\
% proved using sal-inf-bmc -i -d 2 -l helper Linear1 correct
correct : THEOREM
system |- G( f7 >= 0 OR f17 >= 0);
\\

\\
reach : THEOREM
system |- G( ratio <= 1/2 );
\\
END
\end{tabbing}
\end{tt}
\caption{HybridSAL model of the drivetrain case study. The {\tt{control}} module describes the
logic for switching between the different modes of the plant. The first part of the HybridSAL 
model is shown in Figure~\ref{fig:1}. We have also shown some (dummy) properties.}
\label{fig:2}
\end{figure}

The {\tt{control}} module is shown in Figure~\ref{fig:2}. It is  a purely
discrete state transition system -- it involves no differential equations.
The logic for changing the value of {\tt{ratio}} is self evident from
Figure~\ref{fig:2}.

It is also possible to model a {\tt{time triggered}} version of the 
plant and control.  This is shown in Figure~\ref{fig:3}.
The only difference between the timed and untimed model is in the guards
of {\tt{plant}}.  
In the untimed version, we set the guards so that
the value of {\tt{ratio}} changes in every single step.
In the timed version, we can not force the 
value of {\tt{ratio}} to change in every single step (since it may not
depending on the sampling period), and hence we simplify the guards.

\begin{figure}[htb!]
\begin{tt}
\begin{tabbing}
timedDrivetrain: CONTEXT = 
\\
BEGIN
\\
plant: MODULE =
\\
BEGIN
\\
OUTPUT f5, f7, e11, f17:REAL
\\
INPUT ratio: REAL
\\
INI\=TIALIZATION
\\ \>
  f5 = 0; f7 = 0; e11 = 0; f17 = 0
\\
TRANSITION
\\
\mbox{[}
\\
rat\=io = 1/4 -->
\+
\\ 
  f5dot' = e11*10000/2400 - f5/20 ;
\\
  f7dot' = 40 + 20 * f17 - 20 * f7 ;
\\
  e11dot' = f17 * 1000 * 1/4 - f5 * 10000/6 ;
\\
  f17dot' = 100*f7 - 100*f17 - e11* 10000/40
\-
\\ 
 \mbox{[]}
\\ 
rat\=io = 1/3 --> $\ldots$ {\em{ same as before}}
\\
 \mbox{[]}
\\
ratio = 3/7 --> $\ldots$ {\em{ same as before}}
\\
 \mbox{[]}
\\
ratio = 3/5 --> $\ldots$ {\em{ same as before}}
\\
 \mbox{[]}
\\
ratio = 1 --> $\ldots$ {\em{ same as before}}
\\
 \mbox{[]}
\\
ratio = 7/5 --> $\ldots$ {\em{ same as before}}
\\
 \mbox{]}
\\
END;
\\
control: MODULE =
\\
BEG\=IN
\\ \>
 {\em{same as before}}
\\
]
\\
END;
\\

\\
system:MODULE  = plant || control ;
END
\end{tabbing}
\end{tt}
\caption{HybridSAL model of the time triggered implementation of the drivetrain case study. 
But for the guards of {\tt{plant}}, this model is identical to the model in
Figure~\ref{fig:1}.}
\label{fig:3}
\end{figure}

The HybridSAL model(s) can be abstracted using the relational abstraction tools.
The usage of these tools is described in Appendix~\ref{app:1}.
The relational abstraction tool eliminates the differential equations and outputs
a SAL file that contains no differential equations.  The following two
SAL tools can be used to analyze the generated abstract file.
\begin{quote}
 {\tt{sal-inf-bmc}}: SAL infinite bounded model checker
\\
 {\tt{sal-inf-bmc -i}}:  SAL k-induction prover
\end{quote}
We note that these two tools use Yices as their background 
satisfiability modulo theory (SMT) constraint solver.

We have described the modeling aspect of the drivetrain case study.
Analysis results will be presented later.


\bibliographystyle{abbrv}
\bibliography{/homes/tiwari/ConfPapers/ashish/all}

%%\newpage %% For the on-line verification.
%%\appendix{Proofs of Claims}
%%\input{proofs}

\appendix
\section{HybridSAL relational abstracter man pages}
\label{app:1}

\begin{verbatim}
-------------------------------------------------------------------------
NAME
        bin/hsal2hasal - construct relational abstraction of HybridSAL models

SYNOPSIS
        bin/hasal [OPTION]... [FILE]

DESCRIPTION
        Construct a relational abstraction of the model in [FILE].
        Create a new SAL file containing the abstract model.
        Input file is expected to be in HybridSAL (.hsal) syntax, or
        HybridSAL's XML representation (.hxml).
        The new file will have the same name as [FILE], but
        a different extension, .sal

        Options include:
        -c, --copyguard
            Explicitly handle the guards in the continuous dynamics
            as state invariants
        -n, --nonlinear
            Create a nonlinear abstract model
            Note that freely available model checkers are unable
            to handle nonlinear models, hence this option is 
            useful for research purposes only
        -t <T>, --timed <T>
            Create a timed relational abstraction assuming that
            the controller is run every <T> time units.
            <T> should be a number (such as, 0.01)
        -o, --optimize
            Create an optimized relational abstraction.
            Certain transient's are unsoundly eliminated from the
            abstract SAL model to improve performance of the model 
            checkers on the generated SAL model

AUTHOR
        Written by Ashish Tiwari

REPORTING BUGS
        Report bin/hsal2hasal bugs to ashish_dot_tiwari_at_sri_dot_com

COPYRIGHT
        Copyright © 2011 Ashish Tiwari, SRI International.

-------------------------------------------------------------------------

NAME
        hybridsal2xml/hybridsal2xml - convert hybridsal into XML format

SYNOPSIS
        hybridsal2xml/hybridsal2xml [OPTION]... [FILE]

DESCRIPTION
        Parse the HybridSAL file [FILE] (with .hsal extension) and
        create a new file containing the XML representation of [FILE].
        The new file will have the same name as [FILE], but
        a different extension, namely .hxml.

        Options include:
        -o <filename>
            Save the XML in file <filename>, rather than the default name.

AUTHOR
        Written by Ashish Tiwari

REPORTING BUGS
        Report hybridsal2xml bugs to ashish_dot_tiwari_at_sri_dot_com

COPYRIGHT
        Copyright © 2011 Ashish Tiwari, SRI International.

-------------------------------------------------------------------------

NAME
        bin/hxml2hsal - convert hybridsal in XML to standard notation

SYNOPSIS
        bin/hxml2hsal [FILE]

DESCRIPTION
        Pretty print the XML file [FILE] as a HybridSAL file.
        The input is assumed to be a file with extension .hxml
        The output is written in a new file that has the same
        name as [FILE], but a different extension, namely .hsal.

        This is the ``inverse'' of hybridsal2xml tool.

AUTHOR
        Written by Ashish Tiwari

REPORTING BUGS
        Report bin/hxml2hsal bugs to ashish_dot_tiwari_at_sri_dot_com

COPYRIGHT
        Copyright © 2011 Ashish Tiwari, SRI International.

-------------------------------------------------------------------------

NAME
        bin/hasal2sal - convert hybridsal in XML to standard notation

SYNOPSIS
        bin/hasal2sal [FILE]

DESCRIPTION
        Extract the discrete part of the transition system contained in
        the hybrid abstract HybridSAL file [FILE], with .hasal extension, 
        and pretty print it.
        The input is assumed to be a file with extension .hasal
        The output is written in a new file that has the same
        name as [FILE], but a different extension, namely .sal.

        There is no analysis performed; it is a purely syntactic extraction.

AUTHOR
        Written by Ashish Tiwari

REPORTING BUGS
        Report bin/hasal2sal bugs to ashish_dot_tiwari_at_sri_dot_com

COPYRIGHT
        Copyright © 2011 Ashish Tiwari, SRI International.
-------------------------------------------------------------------------
\end{verbatim}

\ignore{
\appendix
\section{Supplementary Material}
\begin{proof}(Proof sketch for Proposition~\ref{prop:corr})
First, let $p(\vec{x})$ be the linear expression
$\vec{c}^T\vec{y}+\vec{d}^T\vec{z}+e$ discovered in Step~(6).
Then,
\begin{eqnarray*}
\frac{dp}{dt} &=& \vec{c}^T(A_1\vec{y}+A_2\vec{z}+\vec{b_1}) +
 \vec{d}^T\vec{b_2}
\; = \; \lambda\vec{c}^T\vec{y}+\lambda\vec{d}^T\vec{z}+\vec{c}^T\vec{b_1} + \vec{d}^T\vec{b_2}
\\
& = & \lambda*(\vec{c}^T\vec{y}+\vec{d}^T\vec{z}+\vec{c})
\; = \; \lambda*p
\end{eqnarray*}
Hence, $p(\vec{x}(t)) = p(\vec{x}(0)) e^{\lambda t}$.
Therefore, the relation added in Step~(6) to $\phi$ 
will hold between an initial state $\vec{x}$ and a future
state $\vec{x'}$.

Next, consider the quadratic relations added to $\phi$ 
in Step~(11).  Let $p_1,p_2$ be as defined in Step~(10).
Then,
\begin{eqnarray*}
\frac{d(p_1^2+p_2^2)}{dt} 
& = &
 2p_1(\alpha p_1-\beta p_2)+2p_2(\beta p_1+\alpha p_2)
\; = \;
 2\alpha(p_1^2 + p_2^2)
\end{eqnarray*}
Hence, 
$p_1(\vec{x}(t))^2+p_2(\vec{x}(t))^2 = 
 (p_1(\vec{x}(0))^2+p_2(\vec{x}(0))^2) e^{2\alpha t}$,
and therefore, the relation added in Step~(11) to $\phi$
will hold between an initial state $\vec{x}$ and a future
state $\vec{x'}$.

Next, consider the relations added in Step~(13).
It is easy to observe that every expression $s(\vec{x},\vec{x'})$ 
in the set $E$ is equal to the time $t$ taken to reach $\vec{x}'$
from $\vec{x}$ following the linear ODE dynamics.
Hence, all these expressions need to be equal, as stated in Step~(13).

Finally, the nonlinear relationship in Equation~\ref{eqn:nl}
holds for any binary reachable
pair of states $(\vec{x},\vec{x'})$ 
because
$$
 \left(\frac{p_i(\vec{x}')}{p_i(\vec{x})}\right)^{n_j} 
 = 
 \left(\frac{p_j(\vec{x}')}{p_j(\vec{x})}\right)^{n_i} 
 =
 e^{n_in_j\lambda_0 t}
$$
\qed
\end{proof}
\endignore}
\end{document}

