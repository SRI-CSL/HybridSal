// $ANTLR 2.7.1: "HybridSalParser.g" -> "HybridSalLexer.java"$

public interface HybridSalTokenTypes {
	int EOF = 1;
	int NULL_TREE_LOOKAHEAD = 3;
	int CONTEXT = 4;
	int CONTEXTBODY = 5;
	int CONTEXTNAME = 6;
	int CONSTANTDECLARATION = 7;
	int PARAMETERS = 8;
	int EXPRESSION = 9;
	int CONDITIONAL = 10;
	int RECORDLITERAL = 11;
	int RECORDENTRY = 12;
	int TYPE = 13;
	int TYPEDECLARATION = 14;
	int ASSERTIONDECLARATION = 15;
	int CONTEXTDECLARATION = 16;
	int MODULEDECLARATION = 17;
	int IDENTIFIER = 18;
	int VARDECL = 19;
	int INPUTDECL = 20;
	int OUTPUTDECL = 21;
	int GLOBALDECL = 22;
	int LOCALDECL = 23;
	int ARRAYTYPE = 24;
	int BASEMODULE = 25;
	int MODULE = 26;
	int BASICTYPE = 27;
	int LAMBDAABSTRACTION = 28;
	int REAL = 29;
	int NZREAL = 30;
	int INTEGER = 31;
	int NZINTEGER = 32;
	int NATURAL = 33;
	int BOOLEAN = 34;
	int TRANSDECL = 35;
	int DEFINITION = 36;
	int SIMPLEDEFINITION = 37;
	int LHS = 38;
	int RHSEXPRESSION = 39;
	int RHSSELECTION = 40;
	int APPLICATION = 41;
	int OR = 42;
	int SIMPLEEXPRESSION = 43;
	int SCALARTYPE = 44;
	int SUBRANGE = 45;
	int FUNCTIONTYPE = 46;
	int TUPLETYPE = 47;
	int RECORDTYPE = 48;
	int CONSTRUCTOR = 49;
	int ACCESSOR = 50;
	int FULLNAME = 51;
	int FIELDDECLARATION = 52;
	int TYPENAME = 53;
	int QUALIFIEDTYPENAME = 54;
	int DEFDECL = 55;
	int FORALLDEFINITION = 56;
	int LABEL = 57;
	int INVARDECL = 58;
	int INITFORDECL = 59;
	int INITDECL = 60;
	int GUARDEDCOMMAND = 61;
	int LABELEDCOMMAND = 62;
	int ASSIGNMENTS = 63;
	int GUARD = 64;
	int NAME = 65;
	int ACTUALTYPES = 66;
	int ACTUALEXPRS = 67;
	int NAMEEXPR = 68;
	int QUALIFIEDNAMEEXPR = 69;
	int EQUATION = 70;
	int DISEQUATION = 71;
	int VARDECLS = 72;
	int NEGATION = 73;
	int IFFEXPRESSION = 74;
	int IMPLICATION = 75;
	int DISJUNCTION = 76;
	int XOREXPRESSION = 77;
	int CONJUNCTION = 78;
	int GTEXPRESSION = 79;
	int GEEXPRESSION = 80;
	int LTEXPRESSION = 81;
	int LEEXPRESSION = 82;
	int PLUSEXPRESSION = 83;
	int MINUSEXPRESSION = 84;
	int MULTEXPRESSION = 85;
	int DIVEXPRESSION = 86;
	int ARGUMENT = 87;
	int ARRAYACCESS = 88;
	int ARRAYSELECTION = 89;
	int RECORDACCESS = 90;
	int RECORDSELECTION = 91;
	int TUPLEACCESS = 92;
	int TUPLESELECTION = 93;
	int UPDATESUFFIX = 94;
	int UPDATE = 95;
	int UPDATEEXPRESSION = 96;
	int UPDATEPOSITION = 97;
	int TUPLELITERAL = 98;
	int ACTUALPARAMETERS = 99;
	int ARRAYLITERAL = 100;
	int INDEXVARDECL = 101;
	int NEXTOPERATOR = 102;
	int SETPREDEXPRESSION = 103;
	int SETLISTEXPRESSION = 104;
	int SOMECOMMANDS = 105;
	int MULTICOMMAND = 106;
	int QUANTIFIEDEXPRESSION = 107;
	int QUANTIFIER = 108;
	int LETEXPRESSION = 109;
	int LETDECLARATIONS = 110;
	int LETDECLARATION = 111;
	int ASYNCHRONOUSCOMPOSITION = 112;
	int SYNCHRONOUSCOMPOSITION = 113;
	int SCALARELEMENT = 114;
	int MODULENAME = 115;
	int QUALIFIEDMODULENAME = 116;
	int MODULEINSTANCE = 117;
	int MODULEACTUALS = 118;
	int NEWOUTPUT = 119;
	int RENAMING = 120;
	int RENAME = 121;
	int HIDING = 122;
	int NEWVARDECLS = 123;
	int MODULEMODELS = 124;
	int MODULEIMPLEMENTS = 125;
	int ASSERTIONPROPOSITION = 126;
	int QUANTIFIEDASSERTION = 127;
	int ASSERTIONOPERATOR = 128;
	int ASSERTIONFORM = 129;
	int MULTISYNCHRONOUS = 130;
	int MULTIASYNCHRONOUS = 131;
	int OBSERVEMODULE = 132;
	int TYPEDECLS = 133;
	int TYPEDECL = 134;
	int WITHMODULE = 135;
	int IDENTIFIERS = 136;
	int RENAMES = 137;
	int STATETYPE = 138;
	int MODINIT = 139;
	int MODTRANS = 140;
	int LC = 141;
	int RC = 142;
	int CLN = 143;
	int LITERAL_CONTEXT = 144;
	int EQ = 145;
	int SEMI = 146;
	int LITERAL_BEGIN = 147;
	int LITERAL_END = 148;
	int LITERAL_TYPE = 149;
	int LB = 150;
	int RB = 151;
	int LITERAL_MODULE = 152;
	int LP = 153;
	int RP = 154;
	int LITERAL_OBLIGATION = 155;
	int LITERAL_CLAIM = 156;
	int LITERAL_LEMMA = 157;
	int LITERAL_THEOREM = 158;
	int AND = 159;
	int IMPLIES = 160;
	int IFF = 161;
	int NOT = 162;
	int LITERAL_FORALL = 163;
	int LITERAL_EXISTS = 164;
	int COMMA = 165;
	int TURNSTILE = 166;
	int LITERAL_IMPLEMENTS = 167;
	int LITERAL_REFINES = 168;
	int DOT = 169;
	int LITERAL_DATATYPE = 170;
	int BANG = 171;
	int UNBOUNDED = 172;
	int DOTDOT = 173;
	int LITERAL_ARRAY = 174;
	int LITERAL_OF = 175;
	int ARROW = 176;
	int RECS = 177;
	int RECE = 178;
	int LITERAL_STATE = 179;
	int XOR = 180;
	int NEQ = 181;
	int GT = 182;
	int GE = 183;
	int LT = 184;
	int LE = 185;
	int PLUS = 186;
	int MINUS = 187;
	int MULT = 188;
	int DIV = 189;
	int LITERAL_INIT = 190;
	int LITERAL_TRANS = 191;
	int QUOTE = 192;
	int LITERAL_LAMBDA = 193;
	int LITERAL_LET = 194;
	int LITERAL_IN = 195;
	int RECEXS = 196;
	int RECEXE = 197;
	int ASSIGN = 198;
	int VBAR = 199;
	int LITERAL_IF = 200;
	int LITERAL_THEN = 201;
	int LITERAL_ELSE = 202;
	int LITERAL_ENDIF = 203;
	int LITERAL_ELSIF = 204;
	int LITERAL_WITH = 205;
	int LONGARROW = 206;
	int ASYNC = 207;
	int SYNC = 208;
	int LITERAL_LOCAL = 209;
	int LITERAL_OUTPUT = 210;
	int LITERAL_RENAME = 211;
	int LITERAL_TO = 212;
	int LITERAL_OBSERVE = 213;
	int LITERAL_INPUT = 214;
	int LITERAL_GLOBAL = 215;
	int LITERAL_DEFINITION = 216;
	int LITERAL_INVARIANT = 217;
	int LITERAL_INITFORMULA = 218;
	int LITERAL_INITIALIZATION = 219;
	int LITERAL_TRANSITION = 220;
	int NUMERAL = 221;
	int WS = 222;
	int SL_COMMENT = 223;
	int PERCENT = 224;
	int HASH = 225;
	int QMARK = 226;
	int ALPHANUM = 227;
	int EQIMPL = 228;
	int SLASH = 229;
	int HYPHEN = 230;
	int STAR = 231;
	int LTE = 232;
	int GTE = 233;
	int ALPHA = 234;
	int OPCHAR1 = 235;
	int OPCHAR = 236;
	int OPCHAR_NO_GT = 237;
	int OPCHAR_NO_EQ = 238;
	int OPCHAR_NO_HYPHEN_OR_GT = 239;
	int DOUBLEQUOTE = 240;
}
